<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - Método Híbrido</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <!-- NUEVO: Librería Marked.js para Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        /* Estilos base */
        html, body {
            font-family: 'Inter', sans-serif;
            background-color: #0D0D0D;
            color: #E0E0E0;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Evita el scroll de la página principal */
        }
        
        /* Contenedor principal del chat */
        #chat-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Cabecera */
        #chat-header {
            background-color: #18181b; /* zinc-900 */
            border-bottom: 1px solid #3f3f46; /* zinc-700 */
            padding: 1rem;
            text-align: center;
            flex-shrink: 0;
        }

        /* Contenedor de mensajes */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* Burbujas de chat */
        .chat-bubble {
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            line-height: 1.6;
        }

        /* Burbuja de IA (Asistente) */
        .chat-bubble-assistant {
            background-color: #18181b; /* zinc-900 */
            border: 1px solid #3f3f46; /* zinc-700 */
            color: #E0E0E0;
            align-self: flex-start;
            border-bottom-left-radius: 0.25rem;
        }

        /* --- NUEVO: Estilos de Markdown para la IA --- */
        .chat-bubble-assistant strong, .chat-bubble-assistant b {
            color: #facc15; /* yellow-400 */
            font-weight: 700;
        }
        .chat-bubble-assistant em, .chat-bubble-assistant i {
            font-style: italic;
        }
        .chat-bubble-assistant ul, .chat-bubble-assistant ol {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            margin-left: 1.25rem;
        }
        .chat-bubble-assistant ul {
            list-style-type: disc;
        }
        .chat-bubble-assistant ol {
            list-style-type: decimal;
        }
        .chat-bubble-assistant li {
            margin-bottom: 0.25rem;
        }
        .chat-bubble-assistant p {
            margin-bottom: 0.5rem; /* Espacio entre párrafos */
        }
        .chat-bubble-assistant p:last-child {
            margin-bottom: 0;
        }
        .chat-bubble-assistant code {
            background-color: #0D0D0D; /* Fondo más oscuro */
            color: #fde047; /* yellow-300 */
            padding: 0.1rem 0.3rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }
        .chat-bubble-assistant pre {
            background-color: #0D0D0D;
            padding: 0.75rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.9em;
        }
        .chat-bubble-assistant a {
            color: #60a5fa; /* blue-400 */
            text-decoration: underline;
        }
        /* --- Fin Estilos Markdown --- */


        /* Burbuja de Usuario */
        .chat-bubble-user {
            background-color: #facc15; /* yellow-400 */
            color: #18181b; /* Color de texto oscuro para contraste */
            align-self: flex-end;
            border-bottom-right-radius: 0.25rem;
        }

        /* Barra de entrada de texto */
        #chat-input-bar {
            background-color: #18181b; /* zinc-900 */
            border-top: 1px solid #3f3f46; /* zinc-700 */
            padding: 1rem;
            flex-shrink: 0;
            display: flex;
            gap: 0.75rem;
        }

        #message-input {
            flex-grow: 1;
            background-color: #0D0D0D;
            border: 1px solid #3f3f46;
            color: #E0E0E0;
            border-radius: 9999px; /* rounded-full */
            padding: 0.75rem 1rem;
            font-size: 1rem;
        }
        #message-input:focus {
            outline: none;
            border-color: #facc15;
            box-shadow: 0 0 0 2px rgba(250, 204, 21, 0.3);
        }

        #send-button {
            background: linear-gradient(90deg, #facc15, #ca8a04);
            color: #18181b;
            border: 1px solid #a16207;
            width: 3rem; /* 56px */
            height: 3rem; /* 56px */
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        #send-button:hover {
            opacity: 0.85;
        }
        #send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Indicador de "escribiendo..." */
        .typing-indicator {
            align-self: flex-start;
            padding: 0.75rem 1rem;
            flex-shrink: 0;
        }
        .dot-flashing {
            position: relative;
            width: 10px;
            height: 10px;
            border-radius: 5px;
            background-color: #facc15;
            color: #facc15;
            animation: dotFlashing 1s infinite linear alternate;
            animation-delay: .5s;
        }
        .dot-flashing::before, .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
            width: 10px;
            height: 10px;
            border-radius: 5px;
            background-color: #facc15;
            color: #facc15;
        }
        .dot-flashing::before {
            left: -15px;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 0s;
        }
        .dot-flashing::after {
            left: 15px;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 1s;
        }
        @keyframes dotFlashing {
            0% { background-color: #facc15; }
            50%, 100% { background-color: rgba(250, 204, 21, 0.2); }
        }

    </style>
</head>
<body>

    <div id="chat-container">
        <!-- Cabecera -->
        <header id="chat-header">
            <h1 class="text-xl font-bold text-yellow-400">Método Híbrido AI</h1>
            <p class="text-sm text-gray-400">Tu asistente de entreno</p>
        </header>

        <!-- Contenedor de Mensajes -->
        <main id="chat-messages">
            <!-- Mensaje inicial de la IA -->
            <div class="chat-bubble chat-bubble-assistant">
                ¡Hola! Soy tu asistente de IA. He cargado tu historial de entreno y tus RMs. ¿En qué te puedo ayudar hoy? ¿Dudas sobre el método, pesos para la próxima sesión o cómo vas progresando?
            </div>
        </main>

        <!-- Indicador de "escribiendo..." -->
        <div id="loading-indicator" class="typing-indicator hidden">
            <div class="dot-flashing"></div>
        </div>

        <!-- Barra de Entrada -->
        <footer id="chat-input-bar">
            <input type="text" id="message-input" placeholder="Escribe tu mensaje...">
            <button id="send-button" title="Enviar">
                <!-- Icono de enviar (SVG) -->
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                    <path d="M3.105 3.105a.75.75 0 01.884-.043l11.998 8.248a.75.75 0 010 1.379l-11.998 8.248a.75.75 0 01-1.261-.921L4.8 12.01l-1.652-4.4a.75.75 0 01.043-.884zM6.25 10.5a.75.75 0 000-1.5H8.5a.75.75 0 000 1.5H6.25z" />
                </svg>
            </button>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            // --- Configuración API Mistral (Según tu petición) ---
            const API_KEY = "evxly62Xv91b752fbnHA2I3HD988C5RT";
            const MODEL_NAME = "mistral-small-latest";
            const API_URL = "https://api.mistral.ai/v1/chat/completions";

            // --- DOM Elements ---
            const chatMessages = document.getElementById('chat-messages');
            const messageInput = document.getElementById('message-input');
            const sendButton = document.getElementById('send-button');
            const loadingIndicator = document.getElementById('loading-indicator');

            // --- Historial de Chat (para la API) ---
            let chatHistory = [];

            // --- Funciones de Cálculo de Contexto (copiadas de progreso.html) ---
            
            /**
             * Calcula el 1RM estimado usando la fórmula de Lombardi.
             */
            function calculateLombardi(weight, reps) {
                if (reps <= 0 || weight <= 0) return 0;
                return parseFloat(weight) * Math.pow(parseFloat(reps), 0.10);
            }

            /**
             * Calcula los e1RMs máximos para los ejercicios clave del historial.
             */
            function calculateAllEstimated1RMs(history) {
                const exercisesToTrack = [
                    "Press de banca plano (barra)",
                    "Curl en barra Z",
                    "Jalón en polea agarre neutro",
                    "Jalón al pecho agarre estrecho"
                ];
                const e1rmMap = new Map();

                for (const date in history) {
                    const log = history[date];
                    if (log && Array.isArray(log.exercises) && log.workoutType !== 'rest') {
                        log.exercises.forEach(ex => {
                            if (exercisesToTrack.includes(ex.name) && Array.isArray(ex.series)) {
                                ex.series.forEach(s => {
                                    const weight = parseFloat(s.weight);
                                    const reps = parseInt(s.reps, 10);
                                    if (!isNaN(weight) && !isNaN(reps) && reps > 0 && weight > 0) {
                                        const e1rm = calculateLombardi(weight, reps);
                                        const currentMax = e1rmMap.get(ex.name) || 0;
                                        if (e1rm > currentMax) {
                                            e1rmMap.set(ex.name, e1rm.toFixed(1) + " kg");
                                        }
                                    }
                                });
                            }
                        });
                    }
                }
                // Convertir Map a Objeto para JSON.stringify
                return Object.fromEntries(e1rmMap);
            }

            /**
             * Obtiene los últimos 5 entrenamientos del historial.
             */
            function getLastWorkouts(history) {
                return Object.values(history)
                    .sort((a, b) => new Date(b.date) - new Date(a.date)) // Ordenar descendente
                    .slice(0, 5) // Tomar los últimos 5
                    .map(log => ({ // Simplificar datos
                        date: log.date,
                        title: log.workoutTitle,
                        exercises: log.exercises.map(ex => ({
                            name: ex.name,
                            series: ex.series
                        }))
                    }));
            }

            /**
             * Carga los datos de localStorage y crea el contexto.
             */
            function getWorkoutDataSummary() {
                try {
                    const historyString = localStorage.getItem('workoutHistory') || '{}';
                    const history = JSON.parse(historyString);
                    
                    const e1rms = calculateAllEstimated1RMs(history);
                    const lastWorkouts = getLastWorkouts(history);

                    const summary = {
                        "e1rm_actuales_estimados": e1rms,
                        "ultimos_entrenamientos": lastWorkouts
                    };

                    return JSON.stringify(summary, null, 2); // Formateado para que la IA lo lea mejor

                } catch (error) {
                    console.error("Error al cargar datos de localStorage:", error);
                    return "No se pudieron cargar los datos del historial.";
                }
            }
            
            /**
             * Crea el System Prompt para la IA.
             */
            function createSystemPrompt() {
                const context = getWorkoutDataSummary();
                return `
Eres 'Método Híbrido AI', un entrenador de IA experto en el 'Método Híbrido' (una mezcla de Heavy Duty y Bilbo).
Tu objetivo es ser un compañero de entrenamiento: motiva, da consejos sobre pesos, responde dudas sobre el método, y analiza el progreso.
Sé conciso y directo, como un entrenador. Habla en español.
Formatea tus respuestas usando Markdown para que sean fáciles de leer (listas, negritas, etc.).

Tienes acceso a los datos de entrenamiento más recientes del usuario. Aquí están:
---
${context}
---
Usa estos datos para fundamentar tus respuestas. Por ejemplo, si te preguntan '¿cuánto debería levantar en press de banca?', consulta sus e1RMs y entrenos pasados para dar una recomendación basada en el método (ej. 80% e1RM para HD, 50% e1RM para Bilbo).
`;
            }

            /**
             * Añade una burbuja de chat al DOM.
             */
            function displayMessage(role, content) {
                const bubble = document.createElement('div');
                bubble.classList.add('chat-bubble', `chat-bubble-${role}`);

                // --- CORRECCIÓN: Renderizar Markdown para la IA ---
                if (role === 'assistant') {
                    // Usar 'marked' para convertir Markdown a HTML
                    // IMPORTANTE: En una app real, sanear esto con DOMPurify.
                    // Aquí confiamos en la salida de la API.
                    bubble.innerHTML = marked.parse(content); 
                } else {
                    // Para el usuario, SIEMPRE usar textContent por seguridad
                    bubble.textContent = content; 
                }
                // --- Fin de la corrección ---

                chatMessages.appendChild(bubble);
                scrollToBottom();
            }

            /**
             * Mantiene el chat scrolleado hacia abajo.
             */
            function scrollToBottom() {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            /**
             * Muestra u oculta el indicador de "escribiendo...".
             */
            function setLoading(isLoading) {
                if (isLoading) {
                    loadingIndicator.classList.remove('hidden');
                    sendButton.disabled = true;
                } else {
                    loadingIndicator.classList.add('hidden');
                    sendButton.disabled = false;
                }
                scrollToBottom(); // Asegurarse de scrollear también al mostrar/ocultar
            }

            /**
             * Envía la solicitud a la API de Mistral con lógica de reintentos.
             */
            async function fetchWithRetry(messages) {
                const MAX_RETRIES = 5; // 5 reintentos
                const RETRY_DELAY = 3000; // 3 segundos de espera
                
                const options = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify({
                        model: MODEL_NAME,
                        messages: messages
                    })
                };

                for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                    try {
                        const response = await fetch(API_URL, options);

                        if (response.ok) {
                            const data = await response.json();
                            return data.choices[0].message.content; // Éxito
                        }

                        if (response.status === 429 && attempt < MAX_RETRIES) {
                            console.warn(`(429) Rate limited. Retrying in ${RETRY_DELAY / 1000}s... (Attempt ${attempt})`);
                            await new Promise(res => setTimeout(res, RETRY_DELAY));
                            continue; // Reintentar
                        }
                        
                        // Si no es 429, o es el último intento, fallar
                        const errorText = await response.text();
                        console.error(`API Error: ${response.status}`, errorText);
                        let userMessage = "Lo siento, ha ocurrido un error al contactar con la IA.";
                        if (response.status === 401) {
                            userMessage = "Error: La clave de API no es válida. Revisa la consola.";
                        }
                        return userMessage; // Devolver mensaje de error al usuario

                    } catch (error) {
                        // Error de red
                        console.error(`Fetch error (Attempt ${attempt}):`, error.message);
                        if (attempt === MAX_RETRIES) {
                             return "Lo siento, estoy teniendo problemas de conexión. Por favor, inténtalo de nuevo más tarde.";
                        }
                        // Esperar antes de reintentar por error de red
                        await new Promise(res => setTimeout(res, RETRY_DELAY));
                    }
                }
            }


            /**
             * Función principal para manejar el envío de mensajes.
             */
            async function handleSendMessage() {
                const userInput = messageInput.value.trim();
                if (userInput === "") return;

                // 1. Mostrar mensaje del usuario
                displayMessage('user', userInput);
                messageInput.value = "";
                
                // 2. Añadir al historial de la API
                chatHistory.push({ role: 'user', content: userInput });

                // 3. Mostrar "escribiendo..."
                setLoading(true);

                // 4. Obtener respuesta de la IA
                const aiResponse = await fetchWithRetry(chatHistory);

                // 5. Ocultar "escribiendo..."
                setLoading(false);

                // 6. Añadir respuesta de IA al historial de la API
                chatHistory.push({ role: 'assistant', content: aiResponse });

                // 7. Mostrar respuesta de IA
                displayMessage('assistant', aiResponse);
            }

            // --- (NUEVO) Ajuste de Altura para Móviles ---
            function resizeChatContainer() {
                const chatContainer = document.getElementById('chat-container');
                if (chatContainer) {
                    // Usar window.innerHeight para obtener la altura real de la ventana
                    // (que cambia cuando aparece el teclado)
                    chatContainer.style.height = `${window.innerHeight}px`;
                }
                // Damos un pequeño retardo para asegurar que el scroll
                // se recalcule *después* de que el DOM se haya pintado
                setTimeout(scrollToBottom, 100); 
            }

            // --- Inicialización ---
            function init() {
                // 1. Crear el prompt del sistema con los datos
                const systemPrompt = createSystemPrompt();
                
                // 2. Inicializar el historial de chat de la API
                chatHistory = [{ role: 'system', content: systemPrompt }];
                
                // 3. Configurar Event Listeners
                sendButton.addEventListener('click', handleSendMessage);
                messageInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // Evita el salto de línea
                        handleSendMessage();
                    }
                });
            }

            // --- Iniciar todo ---
            init();

            // Configurar el ajuste de altura
            window.addEventListener('resize', resizeChatContainer);
            window.addEventListener('orientationchange', resizeChatContainer);
            
            // Llamar una vez al inicio para establecer la altura correcta
            resizeChatContainer(); 

        });
    </script>

</body>
</html>